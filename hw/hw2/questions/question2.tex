\section{Question 2}
    \subsection{(a)}
    The procedure has three recursive calls that split the input in different ways. Other than this, only two if statements are called that perform a comparison and a swap which take only $\Theta(1)$ time. We can simply add up the work being done and scale the inputs to the recursive calls accordingly.
    $T(n) = 2T(n/2) + T(n - 1) + \Theta(1)$

    \subsection{(b)}
    \textbf{Induction Hypothesis:} after calling sort(A, i, j), with j - i $<$ k, A[i..j] is sorted.

    \textbf{Basis:} If k = 0, then i = j and the subarray has one index which is trivially already sorted.

    \textbf{Inductive Step:} We use strong induction to assume if j - i $<$ k + 1 for sort(A, i, j), then the subarray A[i..j] is sorted. Then we use this to prove that if j - i = k + 1 and sort(A, i, j) is called, A[i..j] is sorted.

    The first if statement handles the basis step.
    The first call to sort calls it for i = i and j = m = floor((i + j)/2) which we can assume is sorted if j - i $<$ k + 1. $floor((i + j)/2) - i \leq (j - i)/2 < j - i = k + 1 \implies $ A[i, m] is sorted by IH.
    
    Similarly, the second call to sort calls it for i = m + 1 and j = j which we can assume is sorted if j - i $<$ k + 1. $j - floor((i + j)/2) + 1 \leq (j - i)/2 + 1 < j - i = k + 1 \implies $ A[m + 1, j] is sorted by IH.

    The second if statement takes the largest elements from both sorted halves of the array and places the biggest one at the end of the array. This means only A[i..j-1] needs to be sorted.

    The last call to sort(A, i, j - 1) ensures that the rest of the array is sorted by the inductive hypothesis if j - 1 - i $<$ k + 1 which it is in this case. QED.



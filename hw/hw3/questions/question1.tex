\section{Question 1}
The following will describe the advantages and disadvantages to each of the four options of datastructures that could be used for the implementation of a dictionary that implements insert, search, delete, and rank.

\textbf{Linked List}:
A linked list will allow the insertion of an arbitrary key limited by the number of bits used as its representation. While inserting a key will take $\mathcal{O}(1)$ time, deleting or searching for a key in a linked list takes $\mathcal{O}(n)$ time. The rank operation will iterate through the linked list keeping a count of the number of nodes with a key less than k. This will also take $\mathcal{O}(n)$ time. One advantage to the linked list is that it will only take $\mathcal{O}(n)$ memory irregardless of the operations performed on it and it can grow or shrink easily. One may also consider an ordered linked list, but this causes insert to run in $\mathcal{O}(n)$ while giving an asymptotically unimportant increase in speed to the rank operation - clearly not a viable modification.

\textbf{Array}:
For an array with size m, inserting, deleting and searching for a key $k < m$ will take $\mathcal{O}(1)$ time while requiring a fixed amount of space (or in the case of an arraylist, a continuously increasing amount of space depending on the operations performed on it). The rank operation will take $\mathcal{O}(n)$ time because although the keys are ordered in the array, an iteration must be executed to determine if spots full or not. One major limitation of the array is that the key is limited by the size of the array. Therefore, if the size of the keys are much larger than the number of keys, an unneccessary amount of space is required to maintain the dictonary - clearly not an effective solution.

\textbf{Hasmap}:
A hasmap of size m with n keys supports insertion, deletion, and searching in $\mathcal{O}(1)$ time while supporting an arbitrary key size. The major limitation of the hashmap is the rank operation. To determine the rank of key k, the entire hasmap must be iterated over in order to find every slot with a valid key which takes $\mathcal{O}(m)$ time if the hasmap is implemented with doubled hashing, $\mathcal{O}(n)$ time with a load factor $<$ 1, and $\mathcal{O}(m)$ time with a load factor $\geq$ 1.

\textbf{Self-Balancing Binary Search Tree (SBBST)}:
An SBBST makes a tradeoff for the rank operation. Each operation takes $\mathcal{O}(\log{n})$ time (since this is always a balanced BST) which means the rank operation runs asymptotically faster than all the other datastructures while the other operations run more slowly than the hashmap and the array. In order for the rank operation to run in $\mathcal{O}(\log{n})$ time, each entry (or node depending on how the tree is implemented) must also contain a rank field which tracks how many nodes are smaller than itself. Then, every time the insert and delete operations are called, the parent of the node whose rank changed must be updated recursively which takes $\mathcal{O}(\log{n})$ time. Once rank is called, the key must be found using search which takes $\mathcal{O}(\log{n})$ and then the rank of the entry is returned which takes $\mathcal{O}(1)$ time.

\textbf{Conclusion}:
Assuming each operation is called with the same frequency, the SBBST would be the datastructure of choice because the running time of the hashmap over all operations is at best $\mathcal{O}(n)$ while the worst case running time of the SBBST is $\mathcal{O}(\log{n})$.